{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to yishang's notebook","text":""},{"location":"about/","title":"About","text":""},{"location":"about/#about-me","title":"About me","text":"<p> yishangzhang yishang's notebook   (powered by MkDocs) zhangyi2017@cug.edu.cn (\u611f\u8c22\u5730\u5927\u672a\u6536\u56de\u6211\u7684\u90ae\u7bb1)  </p>"},{"location":"about/#about-notebook","title":"About notebook","text":""},{"location":"about/#usage","title":"usage:","text":"<p>https://squidfunk.github.io/mkdocs-material/  </p> <p>https://shafish.cn/blog/mkdocs/ </p> <p>example</p>"},{"location":"example/","title":"example usage","text":"<p>The HTML specification is maintained by the W3C.</p> <pre><code>Optional&lt;String&gt; message = Optional.ofNullable(record.value()); // (1)\nif (message.isPresent()) {\n    System.out.println(message.get());\n}\n</code></pre> <ol> <li> optional\u5224\u7a7a\u5904\u7406.</li> </ol> <pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre> CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\nprintf(\"Hello world!\\n\");\nreturn 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\nstd::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> m a a bdjfnb;srodnbodsrnbo;drbndrndnbjno c d <p>\u5220\u9664\u7ebfdeleted \u4e0b\u5212\u7ebfadded \u9ad8\u4eaehighlighting tianone  a single </p> <p> Image \u8bf4\u660e</p> <ul> <li> name </li> <li> age</li> <li> tel</li> </ul> <p>We can use Material Icons .</p> <p>We can also use Fontawesome Icons :fontawesome-solid-ambulance:.</p> <p>That's not all, we can also use Octicons :octicons-octoface:.</p>"},{"location":"backend/mends_the_sky/","title":"\u8865\u540e\u7aef\u77e5\u8bc6","text":""},{"location":"course/programming_languages/","title":"\u8bfe\u7a0b\u5730\u5740","text":"<p>part A</p> <p>part B</p> <p>part C</p>"},{"location":"course/rust/","title":"OverView","text":"<p>cheatsheet</p>"},{"location":"course/rust/other/","title":"\u5c16\u62ec\u53f7","text":""},{"location":"course/rust/other/#rust","title":"Rust \u4e2d\u5c16\u62ec\u53f7\u7684\u4f7f\u7528","text":"<p>\u5728 Rust \u4e2d\uff0c\u5c16\u62ec\u53f7<code>&lt;&gt;</code>\u7528\u9014\u5e7f\u6cdb\uff0c\u4e3b\u8981\u7528\u4e8e\u8868\u793a\u6cdb\u578b\u7c7b\u578b\u53c2\u6570\u3001trait \u7ea6\u675f\u548c\u751f\u547d\u5468\u671f\u6ce8\u89e3\u3002\u4ee5\u4e0b\u662f\u5177\u4f53\u7528\u9014\u7684\u603b\u7ed3\uff1a</p>"},{"location":"course/rust/other/#_2","title":"\u6cdb\u578b\u7c7b\u578b\u53c2\u6570","text":"<ul> <li> <p>\u7ed3\u6784\u4f53\u6216\u679a\u4e3e\uff1a   \u5b9a\u4e49\u4e00\u4e2a\u6cdb\u578b\u7ed3\u6784\u4f53\u6216\u679a\u4e3e\u65f6\uff0c\u5728\u5176\u540d\u79f0\u540e\u7d27\u63a5\u5c16\u62ec\u53f7\uff0c\u5185\u90e8\u5305\u542b\u6cdb\u578b\u7c7b\u578b\u53c2\u6570\u3002   <pre><code>struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n</code></pre></p> </li> <li> <p>\u51fd\u6570\u3001\u65b9\u6cd5\u6216 trait\uff1a   \u5b9a\u4e49\u6cdb\u578b\u51fd\u6570\u3001\u65b9\u6cd5\u6216 trait \u65f6\uff0c\u5728\u5176\u540d\u79f0\u540e\u7d27\u63a5\u5c16\u62ec\u53f7\uff0c\u5185\u90e8\u58f0\u660e\u6cdb\u578b\u53c2\u6570\u3002   <pre><code>fn my_function&lt;T&gt;(param: T) {}\n</code></pre></p> </li> </ul>"},{"location":"course/rust/other/#trait","title":"Trait \u7ea6\u675f","text":"<ul> <li> <p><code>impl</code> \u5173\u952e\u5b57\u540e\u9762\uff1a   \u5728\u5bf9\u6cdb\u578b\u7c7b\u578b\u5b9e\u73b0\u67d0\u4e2a trait \u65f6\uff0c\u4f7f\u7528<code>impl&lt;T: SomeTrait&gt;</code>\u6765\u8868\u793a\u7c7b\u578b\u53c2\u6570<code>T</code>\u5e26\u6709\u67d0\u4e9b\u7ea6\u675f\u3002   <pre><code>impl&lt;T: Display&gt; ToString for T {}\n</code></pre></p> </li> <li> <p>\u51fd\u6570\u6216\u65b9\u6cd5\u53c2\u6570\u4e2d\uff1a   \u5728\u6cdb\u578b\u51fd\u6570\u6216\u65b9\u6cd5\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7<code>where</code>\u5b50\u53e5\u5728\u5c16\u62ec\u53f7\u5185\u65bd\u52a0\u66f4\u590d\u6742\u7684 trait \u7ea6\u675f\u3002   <pre><code>fn some_function&lt;T&gt;(param: T)\nwhere\n    T: SomeTrait + AnotherTrait,\n{}\n</code></pre></p> </li> </ul>"},{"location":"course/rust/other/#lifetimes","title":"\u751f\u547d\u5468\u671f\uff08Lifetimes\uff09","text":"<ul> <li> <p>\u7ed3\u6784\u4f53\u3001\u51fd\u6570\u3001\u65b9\u6cd5\u5b9a\u4e49\u4e2d\uff1a   \u751f\u547d\u5468\u671f\u6ce8\u89e3\u4e5f\u4f7f\u7528\u5c16\u62ec\u53f7\uff0c\u5e38\u89c1\u5f62\u5f0f\u4e3a\u6487\u53f7\u5f00\u59cb\u7684\u5c0f\u5199\u5b57\u6bcd\uff0c\u5982<code>&lt;'a&gt;</code>\uff0c\u7528\u4e8e\u6307\u5b9a\u5f15\u7528\u7684\u6709\u6548\u671f\u3002   <pre><code>fn borrow_something&lt;'a&gt;(item: &amp;'a T) {}\n</code></pre></p> </li> <li> <p><code>impl</code> \u5757\u4e2d\uff1a   \u5728\u5bf9\u6cdb\u578b\u7c7b\u578b\u8fdb\u884c\u65b9\u6cd5\u5b9e\u73b0\u65f6\uff0c\u5982\u679c\u65b9\u6cd5\u6d89\u53ca\u5230\u5f15\u7528\uff0c\u53ef\u80fd\u9700\u8981\u58f0\u660e\u751f\u547d\u5468\u671f\u53c2\u6570\u3002   <pre><code>impl&lt;'a&gt; SomeStruct&lt;'a&gt; {}\n</code></pre></p> </li> </ul>"},{"location":"course/rust/other/#_3","title":"\u7efc\u5408\u8bf4\u660e","text":"<p>Rust \u4e2d\u7684\u5c16\u62ec\u53f7<code>&lt;&gt;</code>\u5e7f\u6cdb\u5e94\u7528\u4e8e\u58f0\u660e\uff1a</p> <ul> <li>\u6cdb\u578b\u53c2\u6570\uff08\u7c7b\u578b\u3001trait \u7ea6\u675f\uff09</li> <li>\u751f\u547d\u5468\u671f\u6ce8\u89e3</li> </ul> <p>\u901a\u8fc7\u4e0a\u4e0b\u6587\u6765\u7406\u89e3\u5c16\u62ec\u53f7\u7684\u5177\u4f53\u542b\u4e49\u662f\u5173\u952e\uff0c\u5c16\u62ec\u53f7\u53ef\u4ee5\u51fa\u73b0\u5728\u7c7b\u578b\u540d\u3001trait \u540d\u3001<code>impl</code> \u5173\u952e\u5b57\u540e\u9762\uff0c\u6216\u5176\u5185\u90e8\uff0c\u4ee5\u63d0\u4f9b\u5173\u4e8e\u6cdb\u578b\u53c2\u6570\u3001trait \u7ea6\u675f\u6216\u751f\u547d\u5468\u671f\u7684\u4fe1\u606f\u3002</p>"},{"location":"course/rust/other/#dynamically-sized-types","title":"Dynamically sized types","text":"<p>str is a dynamically sized type (DST). A DST is a type whose size is not known at compile time. Whenever you have a reference to a DST, like &amp;str, it has to include additional information about the data it points to. It is a fat pointer. In the case of &amp;str, it stores the length of the slice it points to. We'll see more examples of DSTs in the rest of the course.</p>"},{"location":"course/rust/rust_cheat_sheet/","title":"basic","text":""},{"location":"course/rust/rust_cheat_sheet/#macro","title":"Macro","text":"println!panic!format!assert! <pre><code>macro_rules! println {\n    () =&gt; { ... };\n    ($($arg:tt)*) =&gt; { ... };\n}\n//============================\n#![allow(unused)]\nfn main() {\n    println!(); // prints just a newline\n    println!(\"hello there!\");\n    println!(\"format {} arguments\", \"some\");\n    let local_variable = \"some\";\n    println!(\"format {local_variable} arguments\");\n}\n</code></pre> <pre><code>macro_rules! panic {\n    ($($arg:tt)*) =&gt; { ... };\n}\n//===========================================\npanic!();\npanic!(\"this is a terrible mistake!\");\npanic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\nstd::panic::panic_any(4); // panic with the value of 4 to be collected elsewher\n</code></pre> <pre><code>macro_rules! format {\n    ($($arg:tt)*) =&gt; { ... };\n}\n//====================================\nformat!(\"test\");                             // =&gt; \"test\"\nformat!(\"hello {}\", \"world!\");               // =&gt; \"hello world!\"\nformat!(\"x = {}, y = {val}\", 10, val = 30);  // =&gt; \"x = 10, y = 30\"\nlet (x, y) = (1, 2);\nformat!(\"{x} + {y} = 3\");                    // =&gt; \"1 + 2 = 3\"\n</code></pre> <pre><code>macro_rules! assert {\n    ($cond:expr $(,)?) =&gt; { ... };\n    ($cond:expr, $($arg:tt)+) =&gt; { ... };\n}\n//====================================\nassert!(true);\n\nfn some_computation() -&gt; bool { true } // a very simple function\n\nassert!(some_computation());\n\n// assert with a custom message\nlet x = true;\nassert!(x, \"x wasn't true!\");\n\nlet a = 3; let b = 27;\nassert!(a + b == 30, \"a = {}, b = {}\", a, b);\n</code></pre>"},{"location":"course/rust/rust_cheat_sheet/#memory-layout","title":"Memory Layout","text":"String&amp;String&amp;str <pre><code>        +---------+--------+----------+\n  Stack | pointer | length | capacity | \n        |  |      |   5    |    5     |\n        +--|------+--------+----------+\n           |\n           |\n           v\n        +---+---+---+---+---+\n Heap:  | H | e | l | l | o |\n        +---+---+---+---+---+\n</code></pre> <pre><code>        --------------------------------------\n        |                                    |         \n   +----v----+--------+----------+      +----|----+\n   | pointer | length | capacity |      | pointer |\n   |    |    |   5    |    5     |      |         |\n   +----|----+--------+----------+      +---------+\n        |        s                          &amp;s \n        |       \n        v       \n      +---+---+---+---+---+\n      | H | e | l | l | o |\n      +---+---+---+---+---+\n</code></pre> <p><pre><code>                      s                              slice\n        +---------+--------+----------+      +---------+--------+\n  Stack | pointer | length | capacity |      | pointer | length |\n        |    |    |   5    |    5     |      |    |    |   4    |\n        +----|----+--------+----------+      +----|----+--------+\n             |        s                           |  \n             |                                    |\n             v                                    | \n           +---+---+---+---+---+                  |\n   Heap:   | H | e | l | l | o |                  |\n           +---+---+---+---+---+                  |\n                 ^                                |\n                 |                                |\n                 +--------------------------------+\n</code></pre> str is a DST type</p>"},{"location":"course/rust/rust_cheat_sheet/#control-flow","title":"Control Flow","text":"ifif/elsematch <pre><code>let number = 3;\nif number &lt; 5 {\n    println!(\"`number` is smaller than 5\");\n}\n</code></pre> <pre><code>let number = 3;\n\nif number &lt; 5 {\n    println!(\"`number` is smaller than 5\");\n} else {\n    println!(\"`number` is greater than or equal to 5\");\n}\n</code></pre> <pre><code>enum Status {\n    ToDo,\n    InProgress,\n    Done\n}\n\nimpl Status {\n    fn is_done(&amp;self) -&gt; bool {\n        match self {\n            Status::Done =&gt; true,\n            // The `|` operator lets you match multiple patterns.\n            // It reads as \"either `Status::ToDo` or `Status::InProgress`\".\n            Status::InProgress | Status::ToDo =&gt; false\n        }\n    }\n}\n</code></pre>"},{"location":"course/rust/rust_cheat_sheet/#loop","title":"Loop","text":"whileforloop <pre><code>let sum = 0;\nlet i = 1;\n// \"while i is less than or equal to 5\"\nwhile i &lt;= 5 {\n    // `+=` is a shorthand for `sum = sum + i`\n    sum += i;\n    i += 1;\n}    \n</code></pre> <pre><code>let mut sum = 0;\nfor i in 1..=5 {\n    sum += i;\n}\n</code></pre> <pre><code>loop {\n        count += 1;\n\n        if count == 3 {\n            println!(\"three\");\n\n            // Skip the rest of this iteration\n            continue;\n        }\n\n        println!(\"{}\", count);\n\n        if count == 5 {\n            println!(\"OK, that's enough\");\n\n            // Exit this loop\n            break;      //(1)\n        }\n    }\n</code></pre> <ol> <li>loop familary with while , but only stop when meet break</li> </ol>"},{"location":"course/rust/rust_cheat_sheet/#derive-macros","title":"Derive macros","text":""},{"location":"course/rust/rust_cheat_sheet/#generic-programming","title":"Generic programming","text":"<pre><code>fn print_if_even&lt;T&gt;(n: T)  //(1)\nwhere\n    T: IsEven + Debug  //(2)\n{\n    if n.is_even() {\n        println!(\"{n:?} is even\");\n    }\n}\n</code></pre> <ol> <li>\u53c2\u6570n\u7684\u7c7b\u578b\u662fT</li> <li>\u8fd9\u91cc\u7684\u5192\u53f7\u610f\u5473\u7740\u7ea6\u675f\uff0c\u7ea6\u675f\u4e3a\u7c7b\u578bT\u5fc5\u987b\u5b9e\u73b0\u67d0\u4e2atrait</li> </ol> <p>Two different trait bounds</p> where clauseinline <pre><code>fn print_if_even&lt;T&gt;(n: T)\nwhere\n    T: IsEven + Debug\n//  ^^^^^^^^^^^^^^^^^\n//  This is a `where` clause\n{\n    // [...]\n}\n</code></pre> <pre><code>fn print_if_even&lt;T: IsEven + Debug&gt;(n: T) {\n    //           ^^^^^^^^^^^^^^^^^\n    //           This is an inline trait bound\n    // [...]\n}\n</code></pre>"},{"location":"course/rust/rust_cheat_sheet/#generics-and-associated-types","title":"Generics and associated types","text":"<p>Example  <pre><code>pub trait From&lt;T&gt; {   //(1)\n    fn from(value: T) -&gt; Self;\n}\n\npub trait Deref {\n    type Target;      //(2)\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target;\n}\n</code></pre></p> <ol> <li>from \u5b9e\u73b0\u4e86\u6cdb\u578b  </li> <li>deref \u5b9e\u73b0\u4e86\u5173\u8054\u7c7b\u578b</li> </ol> <p>\u5173\u8054\u7c7b\u578b\uff0c\u5bf9\u4e8e\u4e00\u79cdstruct ,\u53ea\u53ef\u80fd\u6709\u4e00\u79cd\u5b9e\u73b0  \u800c\u5bf9\u4e8e\u6cdb\u578b\uff0c\u5728impl\u65f6\u53ef\u4ee5\u4f20\u5165\u591a\u79cd\u4e0d\u540c\u7684\u53c2\u6570</p> <p>An associated type is uniquely determined by the trait implementation. you'll only be able to specify one Target for a given type and there won't be any ambiguity.</p>"},{"location":"course/rust/rust_cheat_sheet/#_1","title":"\u5c16\u62ec\u53f7&lt;&gt;","text":"<p>\u5c16\u62ec\u53f7</p>"},{"location":"course/rust/rust_cheat_sheet/#compound-types","title":"\u590d\u5408\u7c7b\u578b\uff08Compound Types\uff09","text":"StructEnumTuplesArray <pre><code>An enumeration is a type that can have a fixed set of values, called variants.\nIn Rust, you define an enumeration using the enum keyword:\n\nenum Status {\n    ToDo,\n    InProgress,\n    Done,\n}\nenum, just like struct, defines a new Rust type.\n</code></pre>"},{"location":"course/rust/rust_cheat_sheet/#trait","title":"Trait","text":"<p>\ud83c\udf1f The trait is defined in the current crate</p> <p>\ud83c\udf1f The implementor type is defined in the current crate </p>"},{"location":"course/rust/rust_cheat_sheet/#operator","title":"Operator","text":"AddSubMulDivRemPartialEqPartialOrd <pre><code>pub trait Add&lt;Rhs = Self&gt; {\n    type Output;\n\n    // Required method\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}\n\n//==========================\n\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -&gt; Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nassert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 });\n</code></pre> <pre><code>pub trait Sub&lt;Rhs = Self&gt; {\n    type Output;\n\n    // Required method\n    fn sub(self, rhs: Rhs) -&gt; Self::Output;\n}\n\n//============================================\nuse std::ops::Sub;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Sub for Point {\n    type Output = Self;\n\n    fn sub(self, other: Self) -&gt; Self::Output {\n        Self {\n            x: self.x - other.x,\n            y: self.y - other.y,\n        }\n    }\n}\n\nassert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n        Point { x: 1, y: 0 });\n</code></pre> <pre><code>pub trait Mul&lt;Rhs = Self&gt; {\n    type Output;\n\n    // Required method\n    fn mul(self, rhs: Rhs) -&gt; Self::Output;\n}\n\n//==========================\nuse std::ops::Mul;\n\n// By the fundamental theorem of arithmetic, rational numbers in lowest\n// terms are unique. So, by keeping `Rational`s in reduced form, we can\n// derive `Eq` and `PartialEq`.\n#[derive(Debug, Eq, PartialEq)]\nstruct Rational {\n    numerator: usize,\n    denominator: usize,\n}\n\nimpl Rational {\n    fn new(numerator: usize, denominator: usize) -&gt; Self {\n        if denominator == 0 {\n            panic!(\"Zero is an invalid denominator!\");\n        }\n\n        // Reduce to lowest terms by dividing by the greatest common\n        // divisor.\n        let gcd = gcd(numerator, denominator);\n        Self {\n            numerator: numerator / gcd,\n            denominator: denominator / gcd,\n        }\n    }\n}\n\nimpl Mul for Rational {\n    // The multiplication of rational numbers is a closed operation.\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -&gt; Self {\n        let numerator = self.numerator * rhs.numerator;\n        let denominator = self.denominator * rhs.denominator;\n        Self::new(numerator, denominator)\n    }\n}\n\n// Euclid's two-thousand-year-old algorithm for finding the greatest common\n// divisor.\nfn gcd(x: usize, y: usize) -&gt; usize {\n    let mut x = x;\n    let mut y = y;\n    while y != 0 {\n        let t = y;\n        y = x % y;\n        x = t;\n    }\n    x\n}\n\nassert_eq!(Rational::new(1, 2), Rational::new(2, 4));\nassert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n        Rational::new(1, 2));\n</code></pre> <pre><code>pub trait Div&lt;Rhs = Self&gt; {\n    type Output;\n\n    // Required method\n    fn div(self, rhs: Rhs) -&gt; Self::Output;\n}\n\n//========\nuse std::ops::Div;\n\n// By the fundamental theorem of arithmetic, rational numbers in lowest\n// terms are unique. So, by keeping `Rational`s in reduced form, we can\n// derive `Eq` and `PartialEq`.\n#[derive(Debug, Eq, PartialEq)]\nstruct Rational {\n    numerator: usize,\n    denominator: usize,\n}\n\nimpl Rational {\n    fn new(numerator: usize, denominator: usize) -&gt; Self {\n        if denominator == 0 {\n            panic!(\"Zero is an invalid denominator!\");\n        }\n\n        // Reduce to lowest terms by dividing by the greatest common\n        // divisor.\n        let gcd = gcd(numerator, denominator);\n        Self {\n            numerator: numerator / gcd,\n            denominator: denominator / gcd,\n        }\n    }\n}\n\nimpl Div for Rational {\n    // The division of rational numbers is a closed operation.\n    type Output = Self;\n\n    fn div(self, rhs: Self) -&gt; Self::Output {\n        if rhs.numerator == 0 {\n            panic!(\"Cannot divide by zero-valued `Rational`!\");\n        }\n\n        let numerator = self.numerator * rhs.denominator;\n        let denominator = self.denominator * rhs.numerator;\n        Self::new(numerator, denominator)\n    }\n}\n\n// Euclid's two-thousand-year-old algorithm for finding the greatest common\n// divisor.\nfn gcd(x: usize, y: usize) -&gt; usize {\n    let mut x = x;\n    let mut y = y;\n    while y != 0 {\n        let t = y;\n        y = x % y;\n        x = t;\n    }\n    x\n}\n\nassert_eq!(Rational::new(1, 2), Rational::new(2, 4));\nassert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n        Rational::new(2, 3));\n</code></pre> <pre><code>pub trait Rem&lt;Rhs = Self&gt; {\n    type Output;\n\n    // Required method\n    fn rem(self, rhs: Rhs) -&gt; Self::Output;\n}\n\n//================================\n\nuse std::ops::Rem;\n\n#[derive(PartialEq, Debug)]\nstruct SplitSlice&lt;'a, T&gt; {\n    slice: &amp;'a [T],\n}\n\nimpl&lt;'a, T&gt; Rem&lt;usize&gt; for SplitSlice&lt;'a, T&gt; {\n    type Output = Self;\n\n    fn rem(self, modulus: usize) -&gt; Self::Output {\n        let len = self.slice.len();\n        let rem = len % modulus;\n        let start = len - rem;\n        Self {slice: &amp;self.slice[start..]}\n    }\n}\n\n// If we were to divide &amp;[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n// the remainder would be &amp;[6, 7].\nassert_eq!(SplitSlice { slice: &amp;[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n        SplitSlice { slice: &amp;[6, 7] });\n</code></pre> <pre><code>pub trait PartialEq {\n    // Required method\n    //\n    // `Self` is a Rust keyword that stands for \n    // \"the type that is implementing the trait\"\n    fn eq(&amp;self, other: &amp;Self) -&gt; bool;\n\n    // Provided method\n    fn ne(&amp;self, other: &amp;Self) -&gt; bool { ... }  //(1)\n}\n\n//====================\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Self;\n\n    fn add(self, other: Self) -&gt; Self {\n        Self {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nassert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 });\n</code></pre> <ol> <li>fn ne is implmented by default</li> </ol> <pre><code>pub trait PartialOrd&lt;Rhs = Self&gt;: PartialEq&lt;Rhs&gt;\nwhere\n    Rhs: ?Sized,\n{\n    // Required method\n    fn partial_cmp(&amp;self, other: &amp;Rhs) -&gt; Option&lt;Ordering&gt;; //(1)\n\n    // Provided methods\n    fn lt(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n    fn le(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n    fn gt(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n    fn ge(&amp;self, other: &amp;Rhs) -&gt; bool { ... }\n}\n\n//\n</code></pre> <ol> <li>the only one need to be done</li> </ol>"},{"location":"course/rust/rust_cheat_sheet/#other","title":"Other","text":"DerefSizedFromIntoCloneCopyDrop <pre><code>//std::ops\npub trait Deref {\n    type Target: ?Sized;\n\n    // Required method\n    fn deref(&amp;self) -&gt; &amp;Self::Target;\n}\n\n//==========================\n\nuse std::ops::Deref;\n\nstruct DerefExample&lt;T&gt; {\n    value: T\n}\n\nimpl&lt;T&gt; Deref for DerefExample&lt;T&gt; {\n    type Target = T;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.value\n    }\n}\n\nlet x = DerefExample { value: 'a' };\nassert_eq!('a', *x);\n</code></pre> <pre><code>pub trait Sized {  //(1)\n    // This is an empty trait, no methods to implement.\n}\n</code></pre> <ol> <li>no methods to implement just means that it is a flag</li> </ol> <p> \u5982\u679c\u4e00\u4e2a\u7ed3\u6784\u4f53\u662f\u6cdb\u578b\u7684\uff0c\u90a3\u4e48\u5b83\u4f1a\u5047\u5b9a\u7ed3\u6784\u4f53\u6240\u5305\u542b\u7684\u7c7b\u578bT\u5b9e\u73b0\u4e86Size \u7684trait</p> <pre><code>pub trait From&lt;T&gt;: Sized {\n    // Required method\n    fn from(value: T) -&gt; Self;\n}\n\n//============================\n\nuse std::fs;\nuse std::io;\nuse std::num;\n\nenum CliError {\n    IoError(io::Error),\n    ParseError(num::ParseIntError),\n}\n\nimpl From&lt;io::Error&gt; for CliError {\n    fn from(error: io::Error) -&gt; Self {\n        CliError::IoError(error)\n    }\n}\n\nimpl From&lt;num::ParseIntError&gt; for CliError {\n    fn from(error: num::ParseIntError) -&gt; Self {\n        CliError::ParseError(error)\n    }\n}\n\nfn open_and_parse_file(file_name: &amp;str) -&gt; Result&lt;i32, CliError&gt; {\n    let mut contents = fs::read_to_string(&amp;file_name)?;\n    let num: i32 = contents.trim().parse()?;\n    Ok(num)\n}\n</code></pre> <p><pre><code>pub trait Into&lt;T&gt;: Sized {\n    // Required method\n    fn into(self) -&gt; T;\n}\n\n//============================\n</code></pre> From\u5b9e\u73b0\u540e\uff0c\u5c06\u81ea\u52a8\u751f\u6210\u4e00\u4e2aInto\u7684\u65b9\u6cd5\uff0c \u5728\u8fd9\u91ccsized \u662f\u7ea6\u675fFrom \u7684trait ,\u4e5f\u5c31\u662f\u7ea6\u675fself,\u610f\u5473\u7740\u5fc5\u987b\u5b9e\u73b0\u4e86sized trait\u7684\u7c7b\u578b\u624d\u80fd\u5b9e\u73b0sized , super trait??</p> <pre><code>pub trait Clone {\n    fn clone(&amp;self) -&gt; Self;\n}\n\n//========================\n</code></pre> <pre><code>pub trait Copy: Clone { } //(1)    \n</code></pre> <ol> <li>copy is an empty trait , which just a trait\uff08Marker Trait\uff09</li> </ol> <p><pre><code>pub trait Drop {\n    // Required method\n    fn drop(&amp;mut self);\n}\n\n//=======================\n\nstruct HasDrop;\n\nimpl Drop for HasDrop {\n    fn drop(&amp;mut self) {\n        println!(\"Dropping HasDrop!\");\n    }\n}\n\nstruct HasTwoDrops {\n    one: HasDrop,\n    two: HasDrop,\n}\n\nimpl Drop for HasTwoDrops {\n    fn drop(&amp;mut self) {\n        println!(\"Dropping HasTwoDrops!\");\n    }\n}\n\nfn main() {\n    let _x = HasTwoDrops { one: HasDrop, two: HasDrop };\n    println!(\"Running!\");\n}\n\n\n//output =========\n\nRunning!\nDropping HasTwoDrops!\nDropping HasDrop!\nDropping HasDrop!\n</code></pre> \u90a3\u4e48\u5982\u679c\u6ca1\u6709\u5b9e\u73b0 Drop trait \u4f1a\u4e0d\u4f1a\u5bfc\u81f4\u5185\u5b58\u6cc4\u6f0f\u5462\uff1f</p> <ul> <li>\u5bf9\u4e8e Rust \u7684\u5806\u5185\u5b58\u6765\u8bf4\uff0c\u5373\u4f7f\u6ca1\u6709\u663e\u5f0f\u5730\u5b9e\u73b0 Drop trait\uff0cRust \u7684\u6240\u6709\u6743\u7cfb\u7edf\u4ecd\u7136\u4f1a\u5728\u5bf9\u8c61\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u81ea\u52a8\u91ca\u653e\u5b83\u6240\u62e5\u6709\u7684\u5185\u5b58\u8d44\u6e90\uff0c\u56e0\u6b64\u4e0d\u4f1a\u53d1\u751f\u5185\u5b58\u6cc4\u6f0f\u3002</li> <li>\u4f46\u662f\uff0c\u5982\u679c\u4f60\u7684\u7c7b\u578b\u4f7f\u7528\u4e86\u9664\u4e86\u5806\u5185\u5b58\u4ee5\u5916\u7684\u5916\u90e8\u8d44\u6e90\uff0c\u6bd4\u5982\u6253\u5f00\u6587\u4ef6\u3001\u7f51\u7edc\u8fde\u63a5\u6216\u8005\u5176\u4ed6\u9700\u8981\u624b\u52a8\u91ca\u653e\u7684\u8d44\u6e90\uff0c\u800c\u6ca1\u6709\u901a\u8fc7\u5b9e\u73b0 Drop trait \u6765\u91ca\u653e\u8fd9\u4e9b\u8d44\u6e90\uff0c\u90a3\u4e48\u8fd9\u4e9b\u8d44\u6e90\u53ef\u80fd\u4e0d\u4f1a\u88ab\u6b63\u786e\u6e05\u7406\uff0c\u4ece\u800c\u5bfc\u81f4\u8d44\u6e90\u6cc4\u6f0f\u3002</li> </ul>"},{"location":"useful_resource/readeable/","title":"effictive_rust","text":"<p>effective_rust https://www.lurklurk.org/effective-rust/  rust cheatsheet https://nootn.com/rust-language-cheat-sheet/#basic-types </p>"}]}